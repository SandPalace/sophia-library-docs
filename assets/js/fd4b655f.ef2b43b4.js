"use strict";(globalThis.webpackChunksophia_library_docs=globalThis.webpackChunksophia_library_docs||[]).push([[889],{7803:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"langgraph-integration","title":"Sophia API Integration Guide for LangGraph Server","description":"This guide helps you integrate the Sophia Library API with your LangGraph agent application.","source":"@site/docs/langgraph-integration.md","sourceDirName":".","slug":"/langgraph-integration","permalink":"/sophia-library-docs/docs/langgraph-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/SandPalace/sophia-library-docs/tree/main/docs/langgraph-integration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"API Reference","permalink":"/sophia-library-docs/docs/api-reference"},"next":{"title":"Python Client","permalink":"/sophia-library-docs/docs/python-client"}}');var r=s(4848),i=s(8453);const a={},o="Sophia API Integration Guide for LangGraph Server",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"1. Prerequisites",id:"1-prerequisites",level:3},{value:"2. API Server Setup",id:"2-api-server-setup",level:3},{value:"3. Authentication",id:"3-authentication",level:3},{value:"Generate an API Key",id:"generate-an-api-key",level:4},{value:"4. Test Connection",id:"4-test-connection",level:3},{value:"Integration with LangGraph",id:"integration-with-langgraph",level:2},{value:"Environment Configuration",id:"environment-configuration",level:3},{value:"Python Client Example",id:"python-client-example",level:3},{value:"Search Methods Explained (Sprints 8-11)",id:"search-methods-explained-sprints-8-11",level:2},{value:"1. Semantic Search (Sprint 8)",id:"1-semantic-search-sprint-8",level:3},{value:"2. Keyword Search (Sprint 9)",id:"2-keyword-search-sprint-9",level:3},{value:"3. Hybrid Search (Sprint 10) - <strong>RECOMMENDED</strong>",id:"3-hybrid-search-sprint-10---recommended",level:3},{value:"Standardized Response Format (Sprint 11)",id:"standardized-response-format-sprint-11",level:3},{value:"Filtering with Qdrant Payload Indexes",id:"filtering-with-qdrant-payload-indexes",level:3},{value:"LangGraph Agent Integration",id:"langgraph-agent-integration",level:2},{value:"Agent Tool Definition",id:"agent-tool-definition",level:3},{value:"Agent Definition",id:"agent-definition",level:3},{value:"API Reference Summary",id:"api-reference-summary",level:2},{value:"Base URL",id:"base-url",level:3},{value:"Authentication",id:"authentication",level:3},{value:"Key Endpoints",id:"key-endpoints",level:3},{value:"Rate Limits",id:"rate-limits",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"API Key Issues",id:"api-key-issues",level:3},{value:"Connection Issues",id:"connection-issues",level:3},{value:"Database Issues",id:"database-issues",level:3},{value:"Qdrant Connection Issues",id:"qdrant-connection-issues",level:3},{value:"OpenSearch Connection Issues",id:"opensearch-connection-issues",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Current System Status",id:"current-system-status",level:2},{value:"Support",id:"support",level:2},{value:"Example: Complete Agent Workflow with Standardized Format",id:"example-complete-agent-workflow-with-standardized-format",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sophia-api-integration-guide-for-langgraph-server",children:"Sophia API Integration Guide for LangGraph Server"})}),"\n",(0,r.jsx)(n.p,{children:"This guide helps you integrate the Sophia Library API with your LangGraph agent application."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Sophia API provides REST endpoints for accessing the library's cataloged philosophical and religious texts, including:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Catalog"})," - Book metadata, summaries, keywords"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authors"})," - Author information and works"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Search"})," - Semantic (Qdrant + embeddings), keyword (OpenSearch + BM25), and hybrid (RRF fusion) search"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Context Building"})," - Comprehensive context aggregation for AI agents"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Current Status (Sprints 8-11 Completed):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 25,552 documents indexed in both Qdrant and OpenSearch"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Semantic search with Qdrant vector database (text-embedding-3-small, 1536 dimensions)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Keyword search with OpenSearch BM25 algorithm"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Hybrid search using Reciprocal Rank Fusion (RRF)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Standardized response format across all search methods"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Qdrant payload indexes for fast filtering (author, content_id, domain, discipline, subfield)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.h3,{id:"1-prerequisites",children:"1. Prerequisites"}),"\n",(0,r.jsx)(n.p,{children:"Before starting the API server, ensure you have:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Python 3.11+"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Qdrant"})," running on localhost:6333 (for semantic search)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"OpenSearch"})," running on localhost:9200 (for keyword search)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Start Qdrant (Vector Database):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Using Docker\ndocker run -p 6333:6333 -p 6334:6334 \\\n    -v $(pwd)/qdrant_storage:/qdrant/storage:z \\\n    qdrant/qdrant\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Start OpenSearch (Search Engine):"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Using Docker Compose (recommended)\ncd /path/to/sophia\ndocker-compose up -d opensearch\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-api-server-setup",children:"2. API Server Setup"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Start the Sophia API server:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd /path/to/sophia\npython services/api/run_api_server.py\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The API will be available at: ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"http://localhost:8888",children:"http://localhost:8888"})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"API Documentation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Swagger UI: ",(0,r.jsx)(n.a,{href:"http://localhost:8888/api/v1/docs",children:"http://localhost:8888/api/v1/docs"})]}),"\n",(0,r.jsxs)(n.li,{children:["ReDoc: ",(0,r.jsx)(n.a,{href:"http://localhost:8888/api/v1/redoc",children:"http://localhost:8888/api/v1/redoc"})]}),"\n",(0,r.jsxs)(n.li,{children:["OpenAPI Spec: ",(0,r.jsx)(n.a,{href:"http://localhost:8888/api/v1/openapi.json",children:"http://localhost:8888/api/v1/openapi.json"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-authentication",children:"3. Authentication"}),"\n",(0,r.jsxs)(n.p,{children:["The API uses ",(0,r.jsx)(n.strong,{children:"API Key authentication"})," with Bearer token scheme."]}),"\n",(0,r.jsx)(n.h4,{id:"generate-an-api-key",children:"Generate an API Key"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'cd /path/to/sophia\npython services/api/scripts/create_api_key.py \\\n  --name "LangGraph Agent Service" \\\n  --role agent_service \\\n  --quota 100000\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u2705 API Key Created Successfully!\n\n  ID:           97795ada-4cf3-453d-8478-5601d2ef359f\n  Name:         LangGraph Agent Service\n  Role:         agent_service\n  Quota:        100000 requests/day\n\n  \ud83d\udd11 API Key:   sk_uIylNiQ0tniLMuxLn3g7o3F4zezxSDn5\n\n\u26a0\ufe0f  IMPORTANT: Save this key now! It won't be shown again.\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Save this API key"})," - you'll need it for all requests."]}),"\n",(0,r.jsx)(n.h3,{id:"4-test-connection",children:"4. Test Connection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Test health endpoint (no auth required)\ncurl http://localhost:8888/api/v1/health\n\n# Test authenticated endpoint\ncurl -H "Authorization: Bearer sk_uIylNiQ0tniLMuxLn3g7o3F4zezxSDn5" \\\n     http://localhost:8888/api/v1/catalog/books?limit=5\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-langgraph",children:"Integration with LangGraph"}),"\n",(0,r.jsx)(n.h3,{id:"environment-configuration",children:"Environment Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Create a ",(0,r.jsx)(n.code,{children:".env"})," file in your LangGraph project:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Sophia API Configuration\nSOPHIA_API_URL=http://localhost:8888/api/v1\nSOPHIA_API_KEY=sk_uIylNiQ0tniLMuxLn3g7o3F4zezxSDn5\n"})}),"\n",(0,r.jsx)(n.h3,{id:"python-client-example",children:"Python Client Example"}),"\n",(0,r.jsx)(n.p,{children:"Create a Sophia API client for your LangGraph agents:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# sophia_client.py\nimport os\nimport requests\nfrom typing import Dict, List, Optional, Any\n\nclass SophiaAPIClient:\n    """Client for interacting with Sophia Library API."""\n\n    def __init__(\n        self,\n        api_url: str = None,\n        api_key: str = None\n    ):\n        self.api_url = api_url or os.getenv("SOPHIA_API_URL", "http://localhost:8888/api/v1")\n        self.api_key = api_key or os.getenv("SOPHIA_API_KEY")\n\n        if not self.api_key:\n            raise ValueError("SOPHIA_API_KEY must be set")\n\n        self.headers = {\n            "Authorization": f"Bearer {self.api_key}",\n            "Content-Type": "application/json"\n        }\n\n    def health_check(self) -> Dict:\n        """Check API health."""\n        response = requests.get(f"{self.api_url}/health")\n        response.raise_for_status()\n        return response.json()\n\n    # Catalog Methods\n\n    def list_books(\n        self,\n        author_slug: str = None,\n        field_tags: List[str] = None,\n        limit: int = 20,\n        offset: int = 0,\n        sort_by: str = "title"\n    ) -> Dict:\n        """List books in catalog."""\n        params = {\n            "limit": limit,\n            "offset": offset,\n            "sort_by": sort_by\n        }\n        if author_slug:\n            params["author_slug"] = author_slug\n        if field_tags:\n            params["field_tags"] = field_tags\n\n        response = requests.get(\n            f"{self.api_url}/catalog/books",\n            headers=self.headers,\n            params=params\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def get_book(self, book_id: str) -> Dict:\n        """Get detailed book information."""\n        response = requests.get(\n            f"{self.api_url}/catalog/books/{book_id}",\n            headers=self.headers\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def get_book_sections(self, book_id: str) -> Dict:\n        """Get section-level summaries for a book."""\n        response = requests.get(\n            f"{self.api_url}/catalog/books/{book_id}/sections",\n            headers=self.headers\n        )\n        response.raise_for_status()\n        return response.json()\n\n    # Author Methods\n\n    def list_authors(\n        self,\n        domain: str = None,\n        discipline: str = None,\n        subfield: str = None,\n        limit: int = 20,\n        offset: int = 0\n    ) -> Dict:\n        """List authors."""\n        params = {"limit": limit, "offset": offset}\n        if domain:\n            params["domain"] = domain\n        if discipline:\n            params["discipline"] = discipline\n        if subfield:\n            params["subfield"] = subfield\n\n        response = requests.get(\n            f"{self.api_url}/authors",\n            headers=self.headers,\n            params=params\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def get_author(self, author_id: str) -> Dict:\n        """Get detailed author information."""\n        response = requests.get(\n            f"{self.api_url}/authors/{author_id}",\n            headers=self.headers\n        )\n        response.raise_for_status()\n        return response.json()\n\n    # Search Methods (Sprints 8-11)\n    # All three methods return standardized format with nested objects\n\n    def semantic_search(\n        self,\n        query: str,\n        filters: Dict = None,\n        top_k: int = 10,\n        score_threshold: float = 0.0,\n        include_sections: bool = False\n    ) -> Dict:\n        """Perform semantic (vector) search using Qdrant.\n\n        Best for: Conceptual queries, questions, paraphrased concepts.\n        Uses OpenAI text-embedding-3-small (1536 dimensions) with cosine similarity.\n\n        Args:\n            query: Search query\n            filters: Optional filters (author_slug, field_tags, book_ids)\n            top_k: Number of results (default 10)\n            score_threshold: Minimum similarity score 0.0-1.0 (default 0.0)\n            include_sections: Include section-level results (default False)\n\n        Returns:\n            Standardized SearchResponse with results and metadata\n        """\n        payload = {\n            "query": query,\n            "top_k": top_k,\n            "score_threshold": score_threshold,\n            "include_sections": include_sections\n        }\n        if filters:\n            payload["filters"] = filters\n\n        response = requests.post(\n            f"{self.api_url}/search/semantic",\n            headers=self.headers,\n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def keyword_search(\n        self,\n        query: str,\n        filters: Dict = None,\n        top_k: int = 10\n    ) -> Dict:\n        """Perform keyword search using OpenSearch BM25.\n\n        Best for: Exact term matching, specific phrases, author names.\n        Uses OpenSearch with BM25 algorithm for full-text keyword matching.\n\n        Args:\n            query: Search query\n            filters: Optional filters (not yet fully implemented for keyword search)\n            top_k: Number of results (default 10)\n\n        Returns:\n            Standardized SearchResponse with results and metadata\n        """\n        payload = {\n            "query": query,\n            "top_k": top_k\n        }\n        if filters:\n            payload["filters"] = filters\n\n        response = requests.post(\n            f"{self.api_url}/search/keyword",\n            headers=self.headers,\n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def hybrid_search(\n        self,\n        query: str,\n        filters: Dict = None,\n        top_k: int = 10,\n        semantic_weight: float = 0.7,\n        keyword_weight: float = 0.3\n    ) -> Dict:\n        """Perform hybrid search combining semantic and keyword using RRF.\n\n        RECOMMENDED: Best for comprehensive results balancing meaning and exactness.\n        Uses Reciprocal Rank Fusion (RRF) to combine semantic and keyword search.\n\n        Args:\n            query: Search query\n            filters: Optional filters (author_slug, field_tags, book_ids)\n            top_k: Number of results (default 10)\n            semantic_weight: Weight for conceptual understanding 0.0-1.0 (default 0.7)\n            keyword_weight: Weight for exact term matching 0.0-1.0 (default 0.3)\n\n        Returns:\n            Standardized SearchResponse with results, metadata, and score breakdown\n        """\n        payload = {\n            "query": query,\n            "top_k": top_k,\n            "semantic_weight": semantic_weight,\n            "keyword_weight": keyword_weight\n        }\n        if filters:\n            payload["filters"] = filters\n\n        response = requests.post(\n            f"{self.api_url}/search/hybrid",\n            headers=self.headers,\n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n\n    # Context Building\n\n    def build_context(\n        self,\n        query: str,\n        context_type: str = "field_expert",  # librarian | field_expert | author\n        sources: Dict = None,\n        filters: Dict = None,\n        max_chunks: int = 20,\n        max_related_works: int = 5\n    ) -> Dict:\n        """Build comprehensive context for agent queries."""\n        payload = {\n            "query": query,\n            "context_type": context_type,\n            "max_chunks": max_chunks,\n            "max_related_works": max_related_works\n        }\n\n        if sources:\n            payload["sources"] = sources\n        else:\n            payload["sources"] = {\n                "include_catalog": True,\n                "include_summaries": True,\n                "include_chunks": True,\n                "include_sections": True,\n                "include_related_works": True\n            }\n\n        if filters:\n            payload["filters"] = filters\n\n        response = requests.post(\n            f"{self.api_url}/context/build",\n            headers=self.headers,\n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n\n\n# Example usage\nif __name__ == "__main__":\n    # Initialize client\n    client = SophiaAPIClient()\n\n    # Test connection\n    health = client.health_check()\n    print(f"API Status: {health[\'status\']}")\n\n    # Search for Nietzsche\'s works\n    books = client.list_books(author_slug="friedrich-nietzsche", limit=5)\n    print(f"\\nFound {books[\'total\']} books by Nietzsche")\n\n    # Hybrid search (recommended - combines semantic + keyword)\n    results = client.hybrid_search(\n        query="What is the will to power?",\n        filters={"author_slug": "friedrich-nietzsche"},\n        top_k=5,\n        semantic_weight=0.7,\n        keyword_weight=0.3\n    )\n\n    # Access standardized response format (Sprint 11)\n    print(f"\\nHybrid search returned {results[\'metadata\'][\'total_results\']} results")\n    print(f"Query time: {results[\'metadata\'][\'query_time_ms\']:.1f}ms\\n")\n\n    for result in results["results"]:\n        # All scores normalized to 0.0-1.0 (comparable across methods)\n        print(f"Score: {result[\'score\']:.3f}")\n\n        # Nested objects for clean structure\n        print(f"Book: {result[\'book\'][\'title\']}")\n        print(f"Author: {result[\'author\'][\'name\']}")\n        print(f"Location: chunk {result[\'location\'][\'chunk_index\']}, "\n              f"pages {result[\'location\'][\'page_start\']}-{result[\'location\'][\'page_end\']}")\n\n        # Score breakdown (hybrid only)\n        if result[\'search_metadata\']:\n            print(f"  Semantic score: {result[\'search_metadata\'][\'semantic_score\']}")\n            print(f"  Keyword score: {result[\'search_metadata\'][\'keyword_score\']}")\n            print(f"  Source type: {result[\'search_metadata\'][\'source_type\']}")\n\n        print(f"Text: {result[\'text\'][:200]}...\\n")\n\n    # Build context for field expert\n    context = client.build_context(\n        query="Explain Nietzsche\'s eternal recurrence",\n        context_type="field_expert",\n        filters={"author_slug": "friedrich-nietzsche"}\n    )\n    print(f"Context built with {context[\'metadata\'][\'total_sources\']} sources")\n    print(f"Estimated tokens: {context[\'metadata\'][\'context_tokens\']}")\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"search-methods-explained-sprints-8-11",children:"Search Methods Explained (Sprints 8-11)"}),"\n",(0,r.jsxs)(n.p,{children:["The Sophia API provides three search methods, all returning a ",(0,r.jsx)(n.strong,{children:"standardized response format"})," for easy integration:"]}),"\n",(0,r.jsx)(n.h3,{id:"1-semantic-search-sprint-8",children:"1. Semantic Search (Sprint 8)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best for"}),": Conceptual queries, questions, paraphrased concepts"]}),"\n",(0,r.jsx)(n.p,{children:"Uses Qdrant vector database with OpenAI text-embedding-3-small embeddings (1536 dimensions)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'results = client.semantic_search(\n    query="How should we live?",\n    filters={"author_slug": "plato"},\n    top_k=10,\n    score_threshold=0.0\n)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Features"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understands meaning and context"}),"\n",(0,r.jsx)(n.li,{children:"Cosine similarity scoring (0.0-1.0)"}),"\n",(0,r.jsx)(n.li,{children:"Qdrant payload indexes for fast filtering"}),"\n",(0,r.jsx)(n.li,{children:"~600ms query time"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-keyword-search-sprint-9",children:"2. Keyword Search (Sprint 9)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best for"}),": Exact term matching, specific phrases, author names"]}),"\n",(0,r.jsx)(n.p,{children:"Uses OpenSearch with BM25 algorithm for full-text keyword matching."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'results = client.keyword_search(\n    query="categorical imperative",\n    filters={"author_slug": "immanuel-kant"},\n    top_k=10\n)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Features"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Exact keyword matching"}),"\n",(0,r.jsx)(n.li,{children:"BM25 scoring algorithm"}),"\n",(0,r.jsx)(n.li,{children:"Field boosting (title^2.0, author^1.5)"}),"\n",(0,r.jsx)(n.li,{children:"~100-200ms query time"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-hybrid-search-sprint-10---recommended",children:["3. Hybrid Search (Sprint 10) - ",(0,r.jsx)(n.strong,{children:"RECOMMENDED"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Best for"}),": Comprehensive results balancing meaning and exactness"]}),"\n",(0,r.jsx)(n.p,{children:"Combines semantic and keyword search using Reciprocal Rank Fusion (RRF)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'results = client.hybrid_search(\n    query="Einstein theory relativity",\n    top_k=10,\n    semantic_weight=0.7,   # Conceptual understanding\n    keyword_weight=0.3     # Exact term matching\n)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Features"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Best of both worlds (semantic + keyword)"}),"\n",(0,r.jsx)(n.li,{children:"RRF fusion algorithm (k=60)"}),"\n",(0,r.jsx)(n.li,{children:"Configurable weights"}),"\n",(0,r.jsx)(n.li,{children:"Score breakdown in response"}),"\n",(0,r.jsx)(n.li,{children:"~800ms query time"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"standardized-response-format-sprint-11",children:"Standardized Response Format (Sprint 11)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"All three search methods return identical structure:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'{\n    "results": [\n        {\n            "chunk_id": "7e8eec35-2b21-53a8-b62f-5437044e8bd0",\n            "score": 0.8542,  # Normalized 0.0-1.0\n\n            # Nested objects for clean structure\n            "book": {\n                "id": "3871b915ccc13144e3124b142c66d23b",\n                "slug": "relativity-special-general-theory",\n                "title": "Relativity: The Special and General Theory"\n            },\n            "author": {\n                "id": "einstein-123",\n                "name": "Albert Einstein",\n                "slug": "albert-einstein"\n            },\n            "location": {\n                "chunk_index": 0,\n                "page_start": 1,\n                "page_end": 3,\n                "section_id": None,\n                "section_title": None\n            },\n\n            "text": "The matched text content...",\n\n            # Score breakdown (hybrid only)\n            "search_metadata": {\n                "semantic_score": 0.5029,\n                "keyword_score": 15.2390,\n                "semantic_rank": 1,\n                "keyword_rank": 1,\n                "source_type": "both"  # "semantic", "keyword", or "both"\n            }\n        }\n    ],\n\n    # Query metadata envelope\n    "metadata": {\n        "query": "theory of relativity",\n        "search_type": "hybrid",\n        "total_results": 10,\n        "returned_results": 10,\n        "query_time_ms": 842.5,\n        "semantic_weight": 0.7,\n        "keyword_weight": 0.3,\n        "filters": None\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Single parser for all search types"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Nested objects for clean structure"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Normalized scores (0.0-1.0, comparable across methods)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Score breakdown for hybrid search"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Query metadata envelope"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"filtering-with-qdrant-payload-indexes",children:"Filtering with Qdrant Payload Indexes"}),"\n",(0,r.jsx)(n.p,{children:"Qdrant has been indexed with the following fields for fast filtering:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Filter by author\nresults = client.semantic_search(\n    query="virtue ethics",\n    filters={"author_slug": "aristotle"}\n)\n\n# Filter by field tags\nresults = client.hybrid_search(\n    query="quantum mechanics",\n    filters={"field_tags": ["Philosophy", "Science"]}\n)\n\n# Filter by book IDs\nresults = client.keyword_search(\n    query="categorical imperative",\n    filters={"book_ids": ["book-id-1", "book-id-2"]}\n)\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Available Qdrant Payload Indexes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"author"})," - Author name"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"content_id"})," - Book ID"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"domain"})," - Academic domain"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"discipline"})," - Academic discipline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"subfield"})," - Academic subfield"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"langgraph-agent-integration",children:"LangGraph Agent Integration"}),"\n",(0,r.jsx)(n.h3,{id:"agent-tool-definition",children:"Agent Tool Definition"}),"\n",(0,r.jsx)(n.p,{children:"Create tools for your LangGraph agents:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from langchain.tools import tool\nfrom sophia_client import SophiaAPIClient\n\n# Initialize client once\nsophia_client = SophiaAPIClient()\n\n@tool\ndef search_library(query: str, author: str = None, search_type: str = "hybrid") -> str:\n    """Search the Sophia philosophical library for relevant passages.\n\n    Uses the standardized search response format from Sprints 8-11.\n\n    Args:\n        query: The search query\n        author: Optional author slug to filter results (e.g., "friedrich-nietzsche")\n        search_type: Type of search - "hybrid" (default), "semantic", or "keyword"\n\n    Returns:\n        Formatted search results with relevant passages and metadata\n    """\n    filters = {"author_slug": author} if author else None\n\n    # Choose search method based on type\n    if search_type == "semantic":\n        results = sophia_client.semantic_search(\n            query=query,\n            filters=filters,\n            top_k=5,\n            score_threshold=0.0\n        )\n    elif search_type == "keyword":\n        results = sophia_client.keyword_search(\n            query=query,\n            filters=filters,\n            top_k=5\n        )\n    else:  # hybrid (recommended)\n        results = sophia_client.hybrid_search(\n            query=query,\n            filters=filters,\n            top_k=5,\n            semantic_weight=0.7,\n            keyword_weight=0.3\n        )\n\n    # Format results using standardized response structure\n    formatted = []\n    formatted.append(f"Search Query: {results[\'metadata\'][\'query\']}")\n    formatted.append(f"Search Type: {results[\'metadata\'][\'search_type\']}")\n    formatted.append(f"Results Found: {results[\'metadata\'][\'total_results\']}")\n    formatted.append(f"Query Time: {results[\'metadata\'][\'query_time_ms\']:.1f}ms\\n")\n\n    for result in results["results"]:\n        # Access nested objects (Sprint 11 standardized format)\n        score = result[\'score\']  # Normalized 0.0-1.0\n        book_title = result[\'book\'][\'title\']\n        author_name = result[\'author\'][\'name\']\n        chunk_index = result[\'location\'][\'chunk_index\']\n        pages = f"{result[\'location\'][\'page_start\']}-{result[\'location\'][\'page_end\']}"\n        text = result[\'text\']\n\n        formatted.append(\n            f"[Score: {score:.3f}] {book_title} by {author_name}\\n"\n            f"Location: Chunk {chunk_index}, Pages {pages}\\n"\n            f"{text[:500]}..."\n        )\n\n        # Include score breakdown for hybrid search\n        if result.get(\'search_metadata\') and results[\'metadata\'][\'search_type\'] == \'hybrid\':\n            sm = result[\'search_metadata\']\n            formatted.append(\n                f"  (Semantic: {sm[\'semantic_score\']:.3f}, "\n                f"Keyword: {sm[\'keyword_score\']:.2f}, "\n                f"Source: {sm[\'source_type\']})"\n            )\n\n    return "\\n\\n---\\n\\n".join(formatted)\n\n\n@tool\ndef get_author_info(author_name: str) -> str:\n    """Get information about a philosophical author.\n\n    Args:\n        author_name: Name of the author to lookup\n\n    Returns:\n        Author biography and works\n    """\n    # List authors and find match\n    authors = sophia_client.list_authors(limit=100)\n\n    # Simple name matching (improve with fuzzy matching if needed)\n    author = next(\n        (a for a in authors["authors"]\n         if author_name.lower() in a["name"].lower()),\n        None\n    )\n\n    if not author:\n        return f"Author \'{author_name}\' not found in library."\n\n    # Get detailed info\n    details = sophia_client.get_author(author["id"])\n\n    return f"""\n**{details[\'name\']}** ({details.get(\'birth_date\', \'Unknown\')} - {details.get(\'death_date\', \'Unknown\')})\n\n{details.get(\'bio_short\', \'No biography available.\')}\n\n**Notable Works:**\n{\', \'.join(details.get(\'notable_works\', []))}\n\n**Works in Library:** {len(details[\'works\'])}\n"""\n\n\n@tool\ndef build_expert_context(query: str, domain: str = None) -> str:\n    """Build comprehensive context for answering philosophical questions.\n\n    Args:\n        query: The philosophical question or topic\n        domain: Optional domain filter (e.g., "Philosophy", "Religious Studies")\n\n    Returns:\n        Rich context including relevant works, passages, and concepts\n    """\n    filters = None\n    if domain:\n        filters = {"field_tags": [domain]}\n\n    context = sophia_client.build_context(\n        query=query,\n        context_type="field_expert",\n        filters=filters,\n        max_chunks=15\n    )\n\n    # Format context for agent\n    formatted = []\n\n    # Add catalog matches\n    if context["context"]["catalog_matches"]:\n        formatted.append("## Relevant Works:")\n        for match in context["context"]["catalog_matches"][:3]:\n            formatted.append(\n                f"- {match[\'book\'][\'title\']} (relevance: {match[\'relevance_score\']:.2f})\\n"\n                f"  {match[\'summary\']}"\n            )\n\n    # Add key passages\n    if context["context"]["content_chunks"]:\n        formatted.append("\\n## Key Passages:")\n        for chunk in context["context"]["content_chunks"][:5]:\n            formatted.append(\n                f"- From {chunk[\'source\']} (score: {chunk[\'score\']:.2f})\\n"\n                f"  {chunk[\'text\'][:400]}..."\n            )\n\n    # Add field context\n    if context["context"]["field_context"]:\n        fc = context["context"]["field_context"]\n        formatted.append(\n            f"\\n## Field Context:\\n"\n            f"Domain: {fc[\'domain\']}\\n"\n            f"Discipline: {fc[\'discipline\']}\\n"\n            f"Key Concepts: {\', \'.join(fc.get(\'key_concepts\', []))}"\n        )\n\n    return "\\n\\n".join(formatted)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"agent-definition",children:"Agent Definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from langgraph.prebuilt import create_react_agent\nfrom langchain_openai import ChatOpenAI\n\n# Create tools list\ntools = [search_library, get_author_info, build_expert_context]\n\n# Create LLM\nllm = ChatOpenAI(model="gpt-4o", temperature=0)\n\n# Create agent\nagent = create_react_agent(\n    llm,\n    tools,\n    state_modifier="""You are a philosophical research assistant with access to the Sophia Library,\na comprehensive collection of philosophical and religious texts.\n\nWhen answering questions:\n1. Use search_library to find relevant passages from specific works\n2. Use get_author_info to provide context about philosophers\n3. Use build_expert_context for comprehensive philosophical questions\n\nAlways cite your sources by mentioning the book titles and authors."""\n)\n\n# Example usage\nresponse = agent.invoke({\n    "messages": [("user", "What did Nietzsche think about the eternal recurrence?")]\n})\n\nprint(response["messages"][-1].content)\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"api-reference-summary",children:"API Reference Summary"}),"\n",(0,r.jsx)(n.h3,{id:"base-url",children:"Base URL"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"http://localhost:8888/api/v1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,r.jsxs)(n.p,{children:["All endpoints (except ",(0,r.jsx)(n.code,{children:"/health"}),") require authentication:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Authorization: Bearer YOUR_API_KEY\n"})}),"\n",(0,r.jsx)(n.h3,{id:"key-endpoints",children:"Key Endpoints"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Endpoint"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"GET"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/health"})}),(0,r.jsx)(n.td,{children:"Health check (no auth)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"GET"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/catalog/books"})}),(0,r.jsx)(n.td,{children:"List books with filters"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"GET"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/catalog/books/{id}"})}),(0,r.jsx)(n.td,{children:"Get book details"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"GET"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/catalog/books/{id}/sections"})}),(0,r.jsx)(n.td,{children:"Get book sections"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"GET"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/authors"})}),(0,r.jsx)(n.td,{children:"List authors"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"GET"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/authors/{id}"})}),(0,r.jsx)(n.td,{children:"Get author details"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/search/semantic"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"Semantic search"})," (Qdrant + embeddings, Sprint 8)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/search/keyword"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"Keyword search"})," (OpenSearch + BM25, Sprint 9)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/search/hybrid"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"Hybrid search"})," (RRF fusion, Sprint 10) - RECOMMENDED"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/context/build"})}),(0,r.jsx)(n.td,{children:"Build agent context"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/auth/login"})}),(0,r.jsx)(n.td,{children:"Get JWT token"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/auth/refresh"})}),(0,r.jsx)(n.td,{children:"Refresh token"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": All three search methods (",(0,r.jsx)(n.code,{children:"/search/semantic"}),", ",(0,r.jsx)(n.code,{children:"/search/keyword"}),", ",(0,r.jsx)(n.code,{children:"/search/hybrid"}),") return the ",(0,r.jsx)(n.strong,{children:"standardized response format"})," implemented in Sprint 11. This means:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Identical response structure across all methods"}),"\n",(0,r.jsx)(n.li,{children:"Normalized scores (0.0-1.0)"}),"\n",(0,r.jsx)(n.li,{children:"Nested objects for book, author, location"}),"\n",(0,r.jsx)(n.li,{children:"Query metadata envelope"}),"\n",(0,r.jsx)(n.li,{children:"Single parser for all search types"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rate-limits",children:"Rate Limits"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Default: 10,000 requests/day per API key"}),"\n",(0,r.jsx)(n.li,{children:"Configurable per key"}),"\n",(0,r.jsxs)(n.li,{children:["Headers included: ",(0,r.jsx)(n.code,{children:"X-RateLimit-Limit"}),", ",(0,r.jsx)(n.code,{children:"X-RateLimit-Remaining"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"api-key-issues",children:"API Key Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem:"})," 401 Unauthorized"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Verify API key format\nassert api_key.startswith("sk_"), "API key should start with \'sk_\'"\n\n# Check authentication header\nheaders = {"Authorization": f"Bearer {api_key}"}  # Note: "Bearer", not "Token"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"connection-issues",children:"Connection Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem:"})," Connection refused"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Check if API server is running\ncurl http://localhost:8888/api/v1/health\n\n# Start the server\ncd /path/to/sophia\npython services/api/run_api_server.py\n"})}),"\n",(0,r.jsx)(n.h3,{id:"database-issues",children:"Database Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem:"})," Database errors"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Run migrations\ncd /path/to/sophia\npython services/api/migrations/run_migrations.py\n"})}),"\n",(0,r.jsx)(n.h3,{id:"qdrant-connection-issues",children:"Qdrant Connection Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem:"})," Qdrant not responding"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Check if Qdrant is running\ncurl http://localhost:6333/collections\n\n# Check collection exists\ncurl http://localhost:6333/collections/sophia_library\n\n# Verify documents indexed\npython -c \"\nfrom services.qdrant.qdrant_service.client import QdrantService\nqs = QdrantService()\ninfo = qs.client.get_collection('sophia_library')\nprint(f'Vectors: {info.points_count}')\nprint(f'Indexes: {info.payload_schema}')\n\"\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expected"}),": 25,552 vectors indexed with payload indexes for author, content_id, domain, discipline, subfield"]}),"\n",(0,r.jsx)(n.h3,{id:"opensearch-connection-issues",children:"OpenSearch Connection Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem:"})," OpenSearch not responding"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Check OpenSearch is running\npython scripts/check_opensearch_connection.py\n\n# Verify index exists\ncurl -X GET "localhost:9200/sophia_library/_count"\n\n# Check cluster health\ncurl -X GET "localhost:9200/_cluster/health"\n\n# View index mapping\ncurl -X GET "localhost:9200/sophia_library/_mapping"\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expected"}),": 25,552 documents indexed with BM25 scoring enabled"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Generate API Key"}),": Use the create_api_key.py script with ",(0,r.jsx)(n.code,{children:"agent_service"})," role"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test Connection"}),": Try the example client code with all three search methods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Integrate Tools"}),": Add Sophia tools to your LangGraph agents"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Hybrid Search"}),": Recommended for most use cases (balances semantic + keyword)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Apply Filters"}),": Use Qdrant payload indexes for fast author/domain filtering"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor Usage"}),": Track API calls via the api_usage table"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scale Up"}),": Adjust rate limits as needed for your use case"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"current-system-status",children:"Current System Status"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Search Implementation (Sprints 8-11): \u2705 COMPLETED"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Sprint 8"}),": Semantic Search (Qdrant + text-embedding-3-small)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Sprint 9"}),": Keyword Search (OpenSearch + BM25)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Sprint 10"}),": Hybrid Search (RRF fusion)"]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Sprint 11"}),": Result Formatting (standardized responses)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"System Capabilities:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"25,552 documents indexed in both Qdrant and OpenSearch"}),"\n",(0,r.jsx)(n.li,{children:"Qdrant payload indexes for fast filtering (author, content_id, domain, discipline, subfield)"}),"\n",(0,r.jsx)(n.li,{children:"All three search methods operational with standardized API responses"}),"\n",(0,r.jsx)(n.li,{children:"Query times: Semantic ~600ms, Keyword ~100-200ms, Hybrid ~800ms"}),"\n",(0,r.jsx)(n.li,{children:"Production ready for LangGraph integration"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"support",children:"Support"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"API Documentation"}),": ",(0,r.jsx)(n.a,{href:"http://localhost:8888/api/v1/docs",children:"http://localhost:8888/api/v1/docs"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quick Start Guide"}),": ",(0,r.jsx)(n.a,{href:"./API_QUICK_START.md",children:"API_QUICK_START.md"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Search Result Format"}),": ",(0,r.jsx)(n.a,{href:"./SEARCH_RESULT_FORMAT_SUMMARY.md",children:"SEARCH_RESULT_FORMAT_SUMMARY.md"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sprint Documentation"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sophia-library-docs/docs/sprints/sprint-8-qdrant-semantic-search",children:"Sprint 8: Semantic Search"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sophia-library-docs/docs/sprints/sprint-9-opensearch-keyword-search",children:"Sprint 9: Keyword Search"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sophia-library-docs/docs/sprints/sprint-10-hybrid-search-retriever",children:"Sprint 10: Hybrid Search"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sophia-library-docs/docs/sprints/sprint-11-search-result-formatting",children:"Sprint 11: Result Formatting"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source Code"}),": ",(0,r.jsx)(n.code,{children:"/path/to/sophia/services/api/"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Issues"}),": Check logs in structured JSON format"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"example-complete-agent-workflow-with-standardized-format",children:"Example: Complete Agent Workflow with Standardized Format"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# 1. Initialize client\nfrom sophia_client import SophiaAPIClient\n\nclient = SophiaAPIClient(\n    api_url=\"http://localhost:8888/api/v1\",\n    api_key=\"sk_uIylNiQ0tniLMuxLn3g7o3F4zezxSDn5\"\n)\n\n# 2. User asks a question\nuser_question = \"What is Nietzsche's critique of traditional morality?\"\n\n# 3. Perform hybrid search (recommended - combines semantic + keyword)\nsearch_results = client.hybrid_search(\n    query=user_question,\n    filters={\"author_slug\": \"friedrich-nietzsche\"},\n    top_k=10,\n    semantic_weight=0.7,\n    keyword_weight=0.3\n)\n\n# 4. Parse standardized response format\nprint(f\"Search Type: {search_results['metadata']['search_type']}\")\nprint(f\"Query Time: {search_results['metadata']['query_time_ms']:.1f}ms\")\nprint(f\"Results: {search_results['metadata']['total_results']}\\n\")\n\n# 5. Extract relevant passages using nested objects\nrelevant_passages = []\nfor result in search_results['results'][:5]:\n    passage = {\n        'text': result['text'],\n        'book': result['book']['title'],\n        'author': result['author']['name'],\n        'score': result['score'],  # Normalized 0.0-1.0\n        'location': f\"Chunk {result['location']['chunk_index']}, \"\n                    f\"Pages {result['location']['page_start']}-{result['location']['page_end']}\",\n    }\n\n    # For hybrid search, include score breakdown\n    if result.get('search_metadata'):\n        passage['semantic_score'] = result['search_metadata']['semantic_score']\n        passage['keyword_score'] = result['search_metadata']['keyword_score']\n        passage['source_type'] = result['search_metadata']['source_type']\n\n    relevant_passages.append(passage)\n\n# 6. Build agent prompt with search results\nagent_prompt = f\"\"\"\nQuestion: {user_question}\n\nRelevant passages from the Sophia Library:\n\n\"\"\"\n\nfor i, passage in enumerate(relevant_passages, 1):\n    agent_prompt += f\"\"\"\nPassage {i} (Score: {passage['score']:.3f}):\nSource: {passage['book']} by {passage['author']}\nLocation: {passage['location']}\nText: {passage['text'][:400]}...\n\n\"\"\"\n\nagent_prompt += \"\"\"\nBased on these passages, provide a comprehensive answer to the question.\nCite specific books and page ranges in your response.\n\"\"\"\n\n# 7. Agent generates response using the enriched context\n# Your LangGraph agent processes this and responds...\n\n# Example: Using with LangGraph ReAct agent\nfrom langgraph.prebuilt import create_react_agent\nfrom langchain_openai import ChatOpenAI\n\nllm = ChatOpenAI(model=\"gpt-4o\", temperature=0)\nagent = create_react_agent(llm, [search_library, get_author_info])\n\nresponse = agent.invoke({\n    \"messages\": [(\"user\", user_question)]\n})\n\nprint(response[\"messages\"][-1].content)\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"This integration guide provides everything needed to connect your LangGraph agents to the Sophia API with the new search capabilities and standardized response format!"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);